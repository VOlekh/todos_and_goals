<!DOCTYPE html>
<html>
  <head>
    <title>Udacity Todos Goals</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
    <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
    <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>
  </head>
  <body>
    <div id='app'></div>
    <script type='text/javascript'>
      function generateId() {
        return (
          Math.random().toString(36).substring(2) +
          new Date().getTime().toString(36)
        );
      }
      // App Code
      const ADD_TODO = "ADD_TODO";
      const REMOVE_TODO = "REMOVE_TODO";
      const TOGGLE_TODO = "TOGGLE_TODO";
      const ADD_GOAL = "ADD_GOAL";
      const REMOVE_GOAL = "REMOVE_GOAL";
      const RECEIVE_DATA = "RECEIVE_DATA";

      function addTodoAction(todo) {
        return {
          type: ADD_TODO,
          todo,
        };
      }
      function removeTodoAction(id) {
        return {
          type: REMOVE_TODO,
          id,
        };
      }
      function toggleTodoAction(id) {
        return {
          type: TOGGLE_TODO,
          id,
        };
      }
      function addGoalAction(goal) {
        return {
          type: ADD_GOAL,
          goal,
        };
      }
      function removeGoalAction(id) {
        return {
          type: REMOVE_GOAL,
          id,
        };
      }

      function receiveDataAction(todos, goals) {
        return {
          type: RECEIVE_DATA,
          // Return object
          todos,
          goals,
        };
      }

      function handleAddTodo(name, cb) {
        return (dispatch) => {
          return API.saveTodo(name)
            .then((todo) => {
              dispatch(addTodoAction(todo));
              cb();
            })
            .catch(() => {
              alert("There was an error. Try again.");
            });
        };
      }

      //Handels logic for API with OU
      function handleDeleteTodo(todo) {
        return (dispatch) => {
          //Return function
          dispatch(removeTodoAction(todo.id));

          return API.deleteTodo(todo.id).catch(() => {
            dispatch(addTodoAction(todo));
            alert("An error occurred. Try again.");
          });
        };
      }

      function handleToggle(id) {
        return (dispatch) => {
          dispatch(toggleTodoAction(id));
          return API.saveTodoToggle(id).catch(() => {
            dispatch(toggleTodoAction(id));
            alert("An error occurred. Try again.");
          });
        };
      }

      function handleAddGoal(name, cb) {
        return (dispatch) => {
          return API.saveGoal(name)
            .then((goal) => {
              dispatch(addGoalAction(goal));
              cb();
            })
            .catch(() => alert("There was an error. Try again."));
        };
      }

      function handleDeleteGoal(goal) {
        return (dispatch) => {
          dispatch(removeGoalAction(goal.id));
          return API.deleteGoal(goal.id).catch(() => {
            dispatch(addGoalAction(goal));
            alert("An error occurred. Try again.");
          });
        };
      }

      function handleInitialData() {
        return (dispatch) => {
          return Promise.all([API.fetchTodos(), API.fetchGoals()]).then(
            ([todos, goals]) => {
              dispatch(receiveDataAction(todos, goals));
            }
          );
        };
      }

      function todos(state = [], action) {
        switch (action.type) {
          case ADD_TODO:
            return state.concat([action.todo]);
          case REMOVE_TODO:
            return state.filter((todo) => todo.id !== action.id);
          case TOGGLE_TODO:
            return state.map((todo) =>
              todo.id !== action.id
                ? todo
                : Object.assign({}, todo, { complete: !todo.complete })
            );
          case RECEIVE_DATA:
            return action.todos;
          default:
            return state;
        }
      }

      function goals(state = [], action) {
        switch (action.type) {
          case ADD_GOAL:
            return state.concat([action.goal]);
          case REMOVE_GOAL:
            return state.filter((goal) => goal.id !== action.id);
          case RECEIVE_DATA:
            ADD_GOAL;
            return action.goals;
          default:
            return state;
        }
      }
      // Create new reducer loading
      //Set default state to true
      function loading(state = true, action) {
        switch (action.type) {
          case RECEIVE_DATA:
            return false;
          default:
            return state;
        }
      }

      const checker = (store) => (next) => (action) => {
        if (
          action.type === ADD_TODO &&
          action.todo.name.toLowerCase().includes("bitcoin")
        ) {
          return alert("Nope. That's a bad idea.");
        }
        if (
          action.type === ADD_GOAL &&
          action.goal.name.toLowerCase().includes("bitcoin")
        ) {
          return alert("Nope. That's a bad idea.");
        }
        return next(action);
      };


      const logger = (store) => (next) => (action) => {
        console.group(action.type);
        console.log("The action: ", action);
        const result = next(action);
        console.log("The new state: ", store.getState());
        console.groupEnd();
        return result;
      };

      const thunk = (store) => (next) => (action) => {
        if (typeof action === "function") {
          return action(store.dispatch);
        }
        return next(action);
      };

      const store = Redux.createStore(
        Redux.combineReducers({
          todos,
          goals,
          // add new property to combine reducers. then add loading to render
          loading,
        }),
        Redux.applyMiddleware(ReduxThunk.default, checker, logger)
      );
    </script>

    <script type="text/babel">
            function List(props) {
              return (
                <ul>
                  {props.items.map((item) => (
                    <li key={item.id}>
                      <span
                        onClick={() => props.toggle && props.toggle(item.id)}
                        style={{
                          textDecoration: item.complete ? "line-through" : "none",
                        }}
                      >
                        {item.name}
                      </span>
                      <button onClick={() => props.remove(item)}>X</button>
                    </li>
                  ))}
                </ul>
              );
            }


            class Todos extends React.Component {
              addItem = (e) => {
                e.preventDefault();
                this.props.dispatch(handleAddTodo(
                this.input.value,
                () => this.input.value = ''
              ))
            }
            removeItem = (todo) => {
              this.props.dispatch(handleDeleteTodo(todo))
            }
            toggleItem = (id) => {
              this.props.dispatch(handleToggle(id))
            }

                // // Adding new todo item, we are not doing Optimistic Update
                // // removing and toggling, doing these actions optimistically. So we're assuming the change will succeed correctly on the server, so we update the UI immediately, and then only roll back to the original state if the API returns an error.
                // //this.input.value - new value to be returned
                // return (
                //   API.saveTodo(this.input.value)
                //     //wen the function resolves we can get a new item = todo from server that we can add to the state of the store
                //     .then((todo) => {
                //       this.props.store.dispatch(addTodoAction(todo));
                //       this.input.value = "";
                //     })
                //     .catch(() => {
                //       alert("There was an error. Try again.");
                //     })
                // );

                //In below code we are updating to do on a UI side, ths dosn't make sence so we rewrite code as above
                // .then((todo) => {
                //   this.props.store.dispatch(addTodoAction(todo))
                //   this.input.value = ''
                // })
                // .catch(() => {
                //   alert('There was an error. Try again.')
                // })
      // Unknown
              //   const name = this.input.value;
              //   this.input.value = "";
              //   this.props.store.dispatch(
              //     addTodoAction({
              //       name,
              //       complete: false,
              //       id: generateId(),
              //     })
              //   );
              // };

              // Remove all code below as it mixing our component-specific code with the API-specific code
              //Optimistic Updates
              // when the remove item is invoked
              // removeItem = (todo) => {
              //   //we remove the item if there is an issue we return an error and then return back the item
              //   this.props.store.dispatch(removeTodoAction(todo.id));
              //   //Update not only UI but also a DB
              //   //Do not wate untill dispatch, update UI immediately
              //   return API.deleteTodo(todo.id)
              //   .catch(() => {
              //     //if there is an error -> return back item
              //     this.props.store.dispatch(addTodoAction(todo));
              //     alert("An error occurred. Try again.");
              //     //do the same for goals
              //   });
              // };

              //Action creator for Thunk
              removeItem = (todo) => {
                // moved logic to handleDeleteTodo, dispatch single action
                // remove store this.props.store.dispatch(handleDeleteTodo(todo));
                this.props.dispatch(handleDeleteTodo(todo));
              };

              //Optimistic Update below is code befor OU
              // toggleItem = (id) => {
              //   this.props.store.dispatch(toggleTodoAction(id));
              //   return API.saveTodoToggle
              // };
              // Code after OU
              toggleItem = (id) => {
                //remove store
                this.props.dispatch(handleToggle(id))
                //move below code to handleToggle
                // this.props.dispatch(toggleTodoAction(id));
                // return API.saveTodoToggle(id).catch(() => {
                //   this.props.store.dispatch(toggleTodoAction(id));
                //   alert("An error occured.Try again.");
                // });
              };
              render() {
                return (
                  <div>
                    <h1>Todo List</h1>
                    <input
                      type="text"
                      placeholder="Add Todo"
                      ref={(input) => (this.input = input)}
                    />
                    <button onClick={this.addItem}>Add Todo</button>
                    <List
                      toggle={this.toggleItem}
                      items={this.props.todos}
                      remove={this.removeItem}
                    />
                  </div>
                );
              }
            }

            class ConnectedTodos extends React.Component {
              render() {
                return (
                  <Context.Consumer>
                    {(store) => {
                      const { todos } = store.getState();

                      return <Todos todos={todos} dispatch={store.dispatch} />;
                    }}
                  </Context.Consumer>
                );
              }
            }

            class Goals extends React.Component {
              addItem = (e) => {
                e.preventDefault()
                this.props.dispatch(handleAddGoal(
                  this.input.value,
                  () => this.input.value = ''
              ))
              }
              removeItem = (goal) => {
                this.props.dispatch(handleDeleteGoal(goal))
              }
              render() {
                return (
                  <div>
                    <h1>Goals</h1>
                    <input
                      type='text'
                      placeholder='Add Goal'
                      ref={(input) => this.input = input}
                    />
                    <button onClick={this.addItem}>Add Goal</button>
                    <List
                      items={this.props.goals}
                      remove={this.removeItem}
                    />
                  </div>
                )
              }
            }

            class ConnectedGoals extends React.Component {
              render() {
                return (
                  <Context.Consumer>
                    {(store) => {
                      const { goals } = store.getState()

                      return <Goals goals={goals} dispatch={store.dispatch} />
                    }}
                  </Context.Consumer>
                )
              }
            }



                //Below code replaced with above. Below works only with UI
                // const name = this.input.value;
                // this.input.value = "";
                // this.props.store.dispatch(
                //   addGoalAction({
                //     id: generateId(),
                //     name,
                //   })
                // );

              removeItem = (goal) => {
                this.props.store.dispatch(removeGoalAction(goal.id));
                // return API.deleteGoal(goal.id).catch(() => {
                //   this.props.store.dispatch(addGoalAction(goal));
                //   alert("An error occurred. Try again.");
                // });
            //   };
            //   render() {
            //     return (
            //       <div>
            //         <h1>Goals</h1>
            //         <input
            //           type="text"
            //           placeholder="Add Goal"
            //           ref={(input) => (this.input = input)}
            //         />
            //         <button onClick={this.addItem}>Add Goal</button>
            //         <List items={this.props.goals} remove={this.removeItem} />
            //       </div>
            //     );
            //   }
            // }

            class App extends React.Component {
              // When the app loads, console.log all of the todos and all of the goals that reside in our fake database
              componentDidMount() {
                const { store } = this.props;
                store.dispatch(handleInitialData())
                store.subscribe(() => this.forceUpdate())

                // Promise.all([API.fetchTodos(), API.fetchGoals()]).then(
                //   ([todos, goals]) => {
                //     // console.log('Todos', todos)
                //     // console.log('Goals', goals)
                //     store.dispatch(receiveDataAction(todos, goals));
                //   }
                // );

                store.subscribe(() => this.forceUpdate());
              }
              render() {
                const { store } = this.props;
                //Update render with loading
                const {loading } = store.getState();
                if (loading === true) {
                  return <h3>Loading ...</h3>;
                }

                return (
                  // <div>
                    //Remiove
                  //   <Todos todos={todos} store={this.props.store} />
                  //   <Goals goals={goals} store={this.props.store} />
                  // </div>
                  <div>
                    <ConnectedTodos />
                    <ConnectedGoals />
                  </div>
                );
              }
            }
            //Connected component" = "Container Component"
            //A connected component is connected to the Redux store and is responsible for getting data from the store.
            //pass function as chiaild
            class ConnectedApp extends React.Component {
              render() {
                return (
                  <Context.Consumer>
                    {(store) => <App store={store} />}
                  </Context.Consumer>
                );
              }
            }

            const Context = React.createContext();
            // Create own provider
            class Provider extends React.Component {
              render() {
                return (
                  //pass store to Provider component as a prop
                  <Context.Provider value={this.props.store}>
                    {this.props.children}
                  </Context.Provider>
                );
              }
            }

            ReactDOM.render(
              // Removed <App store={store}/>,
              // Pass to provider store as a prop
              <Provider store={store}>
                <ConnectedApp />
              </Provider>,

              document.getElementById("app")
            );
    </script>
  </body>
</html>